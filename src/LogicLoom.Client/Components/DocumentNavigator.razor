@using LogicLoom.Shared.Models
@using LogicLoom.Client.Services
@inject IDocumentService DocumentService

<div class="document-navigator">
    <div class="search-container">
        <div class="input-group">
            <input type="text" class="form-control" placeholder="Search documents..." 
                   @bind="_searchQuery" @bind:event="oninput" @onkeyup="HandleSearch" />
            <button class="btn btn-outline-secondary" type="button" @onclick="PerformSearch">
                <i class="bi bi-search"></i>
            </button>
        </div>
    </div>

    <div class="document-list">
        @if (_isLoading)
        {
            <div class="loading-indicator">
                <div class="spinner-border spinner-border-sm" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <span>Loading documents...</span>
            </div>
        }
        else if (_documents?.Any() != true)
        {
            <div class="no-documents">
                <i class="bi bi-file-earmark-text"></i>
                <span>No documents found</span>
            </div>
        }
        else
        {
            @foreach (var doc in _documents)
            {
                <div class="document-item @(doc.DocumentId == SelectedDocumentId ? "selected" : "")" 
                     @onclick="() => OnDocumentSelected(doc.DocumentId)">
                    <i class="bi bi-file-earmark-text"></i>
                    <div class="document-info">
                        <div class="document-title">@GetDocumentTitle(doc)</div>
                        <div class="document-preview">@doc.Preview</div>
                    </div>
                </div>
            }

            @if (_hasMoreDocuments)
            {
                <button class="btn btn-link load-more" @onclick="LoadMoreDocuments">
                    Load more...
                </button>
            }
        }
    </div>
</div>

<style>
    .document-navigator {
        display: flex;
        flex-direction: column;
        height: 100%;
        border-right: 1px solid var(--vscode-panel-border);
        background: var(--vscode-sideBar-background);
    }

    .search-container {
        padding: 8px;
        border-bottom: 1px solid var(--vscode-panel-border);
    }

    .document-list {
        flex: 1;
        overflow-y: auto;
        padding: 8px;
    }

    .document-item {
        display: flex;
        align-items: start;
        padding: 8px;
        margin-bottom: 4px;
        border-radius: 4px;
        cursor: pointer;
        gap: 8px;
    }

    .document-item:hover {
        background: var(--vscode-list-hoverBackground);
    }

    .document-item.selected {
        background: var(--vscode-list-activeSelectionBackground);
        color: var(--vscode-list-activeSelectionForeground);
    }

    .document-info {
        flex: 1;
        min-width: 0;
    }

    .document-title {
        font-weight: 500;
        margin-bottom: 4px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .document-preview {
        font-size: 0.9em;
        color: var(--vscode-descriptionForeground);
        overflow: hidden;
        text-overflow: ellipsis;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
    }

    .loading-indicator {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 16px;
        color: var(--vscode-descriptionForeground);
    }

    .no-documents {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        padding: 32px 16px;
        color: var(--vscode-descriptionForeground);
    }

    .load-more {
        width: 100%;
        text-align: center;
        padding: 8px;
        cursor: pointer;
    }

    .load-more:hover {
        background: var(--vscode-list-hoverBackground);
    }
</style>

@code {
    [Parameter]
    public Guid? SelectedDocumentId { get; set; }

    [Parameter]
    public EventCallback<Guid> OnDocumentSelectedChanged { get; set; }

    private string _searchQuery = "";
    private List<DocumentInfo> _documents = new();
    private bool _isLoading;
    private bool _hasMoreDocuments;
    private int _currentPage = 1;
    private const int PageSize = 10;
    private System.Threading.Timer? _searchTimer;

    protected override async Task OnInitializedAsync()
    {
        await LoadDocuments();
    }

    private async Task HandleSearch()
    {
        if (_searchTimer != null)
        {
            await _searchTimer.DisposeAsync();
        }

        _searchTimer = new System.Threading.Timer(async _ =>
        {
            await InvokeAsync(async () =>
            {
                _currentPage = 1;
                await LoadDocuments(true);
                _searchTimer = null;
            });
        }, null, 500, System.Threading.Timeout.Infinite);
    }

    private async Task PerformSearch()
    {
        _currentPage = 1;
        await LoadDocuments(true);
    }

    private async Task LoadDocuments(bool isSearch = false)
    {
        try
        {
            _isLoading = true;
            StateHasChanged();

            if (isSearch && !string.IsNullOrWhiteSpace(_searchQuery))
            {
                var results = await DocumentService.SearchDocumentsAsync(_searchQuery);
                _documents = results.Select(r => new DocumentInfo(r.DocumentId, r.Preview)).ToList();
                _hasMoreDocuments = false;
            }
            else
            {
                // In a real implementation, you would have a paginated API endpoint
                // For now, we'll simulate pagination with the search results
                var allDocs = await DocumentService.SearchDocumentsAsync("");
                var pagedDocs = allDocs
                    .Skip((_currentPage - 1) * PageSize)
                    .Take(PageSize)
                    .ToList();

                if (_currentPage == 1)
                {
                    _documents = pagedDocs.Select(r => new DocumentInfo(r.DocumentId, r.Preview)).ToList();
                }
                else
                {
                    _documents.AddRange(pagedDocs.Select(r => new DocumentInfo(r.DocumentId, r.Preview)));
                }

                _hasMoreDocuments = allDocs.Count() > _currentPage * PageSize;
            }
        }
        finally
        {
            _isLoading = false;
            StateHasChanged();
        }
    }

    private async Task LoadMoreDocuments()
    {
        _currentPage++;
        await LoadDocuments();
    }

    private async Task OnDocumentSelected(Guid documentId)
    {
        await OnDocumentSelectedChanged.InvokeAsync(documentId);
    }

    private string GetDocumentTitle(DocumentInfo doc)
    {
        return $"Document {doc.DocumentId}";
    }

    private record DocumentInfo(Guid DocumentId, string Preview);

    public void Dispose()
    {
        if (_searchTimer != null)
        {
            _searchTimer.Dispose();
        }
    }
}
